<!doctype html>
<html lang="cs">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Snow Screensaver</title>
  <meta name="description" content="Klikac√≠ v√°noƒçn√≠ snƒõhov√Ω spo≈ôiƒç ‚Äî React + Canvas v jednom HTML souboru" />
  <style>html,body,#root{height:100%;margin:0}body{background:#0b1220}</style>
  <script src="https://cdn.tailwindcss.com"></script>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
  <div id="root"></div>
  <!-- V≈°echno n√≠≈æe bƒõ≈æ√≠ bez buildov√°n√≠: TSX je p≈ôelo≈æeno v prohl√≠≈æeƒçi pomoc√≠ Babel Standalone. -->
  <script type="text/babel" data-presets="typescript,react">
    const { useEffect, useRef, useState } = React;

    // === P≈òENESEN√Å KOMPONENTA ZE ST√ÅVAJ√çC√çHO K√ìDU ===
    function SnowScreensaver() {
      const canvasRef = useRef(null);
      const rafRef = useRef(null);
      const dprRef = useRef(1);

      const [hintVisible, setHintVisible] = useState(true);
      const [xmasMode, setXmasMode] = useState(true);
      const [soundOn, setSoundOn] = useState(true);
      const [garlandCount, setGarlandCount] = useState(3);
      const [hexOn, setHexOn] = useState(true);
      const [flakeCount, setFlakeCount] = useState(300);
      const [uiVisible, setUiVisible] = useState(true);
      const [depositScale, setDepositScale] = useState(1);

      const flakeCountRef = useRef(300);
      useEffect(()=>{flakeCountRef.current = flakeCount;},[flakeCount]);
      const depositScaleRef = useRef(1);
      useEffect(()=>{depositScaleRef.current = depositScale;},[depositScale]);

      const xmasRef = useRef(true), soundRef = useRef(true), garlandCountRef = useRef(3), hexRef = useRef(true);
      useEffect(()=>{xmasRef.current = xmasMode;},[xmasMode]);
      useEffect(()=>{soundRef.current = soundOn;},[soundOn]);
      useEffect(()=>{garlandCountRef.current = garlandCount;},[garlandCount]);
      useEffect(()=>{hexRef.current = hexOn;},[hexOn]);

      const audioRef = useRef(null);
      function ensureAudio(){ if(!audioRef.current){ const Ctx = window.AudioContext || window.webkitAudioContext; if(Ctx) audioRef.current = new Ctx(); } }

      useEffect(()=>{
        const canvas = canvasRef.current; const ctx = canvas.getContext('2d');
        let width=0, height=0, last=performance.now(), elapsed=0, running=true;
        const flakes=[], special=[], dust=[], sparks=[], logos=[], flashes=[], shockwaves=[];

        // --- ground bins ---
        let groundBins=[]; let groundBinW=4;
        function initGround(){ groundBinW=Math.max(2,Math.floor(4*dprRef.current)); const n=Math.max(1,Math.ceil(width/groundBinW)); groundBins=new Array(n).fill(0); }
        function groundHAt(px){ if(!groundBins.length) return 0; const idx=Math.max(0,Math.min(groundBins.length-1,Math.floor(px/groundBinW))); return groundBins[idx]; }
        function addSnowWide(px,totalAmt,radiusBins=10){ if(!groundBins.length) return; const idx0=Math.floor(px/groundBinW); const r=Math.max(3,Math.min(24,Math.floor(radiusBins))); const sigma=r*0.6; let sum=0; for(let k=-r;k<=r;k++) sum += Math.exp(-(k*k)/(2*sigma*sigma)); for(let k=-r;k<=r;k++){ const j=idx0+k; if(j<0||j>=groundBins.length) continue; const w=Math.exp(-(k*k)/(2*sigma*sigma))/sum; groundBins[j]=Math.min(height*0.45, groundBins[j] + totalAmt*depositScaleRef.current*w); } }
        function addSnow(px,amt){ if(!groundBins.length) return; const idx=Math.floor(px/groundBinW); for(let k=-2;k<=2;k++){ const j=idx+k; if(j<0||j>=groundBins.length) continue; const w = k===0?1:(Math.abs(k)===1?0.6:0.3); groundBins[j]=Math.min(height*0.45, groundBins[j]+amt*depositScaleRef.current*w); } const j0=Math.max(1,Math.min(groundBins.length-2,idx)); groundBins[j0] = (groundBins[j0-1]+groundBins[j0]+groundBins[j0+1])/3; }
        function removeSnow(px,amt){ if(!groundBins.length) return; const idx=Math.floor(px/groundBinW); for(let k=-3;k<=3;k++){ const j=idx+k; if(j<0||j>=groundBins.length) continue; const w = k===0?0.7:(Math.abs(k)===1?0.6:(Math.abs(k)===2?0.45:0.25)); groundBins[j]=Math.max(0, groundBins[j]-amt*w); } for(let i=0;i<Math.floor(30+amt*2);i++) dust.push(new DustParticle(px+rand(-6,6), height-groundHAt(px)+rand(-8,2))); }
        function drawSnowGround(){ if(!groundBins.length) return; ctx.save(); let maxSnow=0; for(let i=0;i<groundBins.length;i++) if(groundBins[i]>maxSnow) maxSnow=groundBins[i]; const yTop=height-maxSnow; const fadeLen=Math.max(60, Math.min(180, 40+maxSnow*0.35)); const g=ctx.createLinearGradient(0, yTop+fadeLen, 0, yTop); g.addColorStop(0,'rgba(255,255,255,0.95)'); g.addColorStop(1,'rgba(255,255,255,0.0)'); ctx.fillStyle=g; ctx.beginPath(); ctx.moveTo(0,height); for(let i=0;i<groundBins.length;i++){ const x=i*groundBinW; const y=height-groundBins[i]; ctx.lineTo(x,y); } ctx.lineTo(width,height); ctx.closePath(); ctx.fill(); ctx.globalCompositeOperation='lighter'; ctx.strokeStyle='rgba(255,255,255,0.6)'; ctx.lineWidth=Math.max(1,1.2*dprRef.current); ctx.beginPath(); for(let i=0;i<groundBins.length;i++){ const x=i*groundBinW; const y=height-groundBins[i]; if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);} ctx.stroke(); ctx.restore(); }

        // parallax stars
        const starLayers=[]; const starSpeeds=[0.02,0.05,0.09]; let pX=0.5,pY=0.5,tPX=0.5,tPY=0.5; const phaseX=Math.random()*Math.PI*2, phaseY=Math.random()*Math.PI*2;
        function buildParallax(){ starLayers.length=0; const area=(width*height)/(800*600); const counts=[Math.max(40,Math.floor(60*area)),Math.max(60,Math.floor(90*area)),Math.max(90,Math.floor(130*area))]; for(let l=0;l<counts.length;l++){ const arr=[]; for(let i=0;i<counts[l];i++){ arr.push({x:Math.random()*width, y:Math.random()*height*0.6, r:Math.random()*(l+1)*0.6+0.3, a:Math.random()*0.6+0.3}); } starLayers.push(arr);} }
        function drawParallax(t){ ctx.save(); for(let l=0;l<starLayers.length;l++){ const arr=starLayers[l]; const sp=starSpeeds[l]; const offX=(pX-0.5)*30 + t*10*sp; const offY=(pY-0.5)*12; ctx.globalAlpha=0.6; for(let s of arr){ let x=(s.x+offX)%width; if(x<0) x+=width; let y=s.y+offY; ctx.beginPath(); ctx.arc(x,y,s.r,0,Math.PI*2); ctx.fillStyle=`rgba(255,255,255,${s.a})`; ctx.fill(); } } ctx.restore(); }

        // garlands
        function shuffle(a){ const r=[...a]; for(let i=r.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [r[i],r[j]]=[r[j],r[i]]; } return r; }
        const garlands=[]; const FW_COLORS=["rgba(255,120,120,ALPHA)","rgba(255,220,120,ALPHA)","rgba(120,220,255,ALPHA)","rgba(140,255,160,ALPHA)","rgba(220,140,255,ALPHA)","rgba(255,255,255,ALPHA)"];

        class Bulb{ constructor(x,y){ this.x=x; this.y=y; this.size=Math.max(1,0.9*dprRef.current)*rand(6,9); this.phase=rand(0,Math.PI*2); this.speed=rand(1.2,2.2); const COLORS=[{fill:'rgb(255,78,78)',glow:'rgba(255,78,78,0.9)'},{fill:'rgb(255,214,67)',glow:'rgba(255,214,67,0.9)'},{fill:'rgb(67,192,255)',glow:'rgba(67,192,255,0.9)'},{fill:'rgb(120,255,120)',glow:'rgba(120,255,120,0.9)'},{fill:'rgb(194,120,255)',glow:'rgba(194,120,255,0.9)'}]; this.color=COLORS[Math.floor(rand(0,COLORS.length))]; }
          draw(ctx,t){ const flick=0.55+0.45*Math.max(0,Math.sin(this.phase+t*this.speed)); if(xmasRef.current && Math.random()<0.25*(1+flick)*0.016 && Math.random()<0.35){ spawnSparkBurst(this.x,this.y,Math.floor(rand(4,9))); }
            const glowR=this.size*5.2; const rg=ctx.createRadialGradient(this.x,this.y,0,this.x,this.y,glowR); rg.addColorStop(0,this.color.glow.replace('0.9',(0.72*flick).toFixed(3))); rg.addColorStop(1,'transparent'); ctx.save(); ctx.globalCompositeOperation='lighter'; ctx.fillStyle=rg; ctx.beginPath(); ctx.arc(this.x,this.y,glowR,0,Math.PI*2); ctx.fill(); ctx.shadowBlur=this.size*2.2; ctx.shadowColor=this.color.glow; ctx.fillStyle=this.color.fill; ctx.beginPath(); ctx.ellipse(this.x,this.y,this.size*0.7,this.size,0,0,Math.PI*2); ctx.fill(); ctx.shadowBlur=0; ctx.fillStyle='#2a3b48'; ctx.fillRect(this.x-this.size*0.5,this.y-this.size*1.2,this.size,this.size*0.35); ctx.restore(); }
        }
        function layoutGarlands(){ garlands.length=0; const count=Math.max(1, Math.min(6, garlandCountRef.current|0)); for(let i=0;i<count;i++){ const frac = count===1?0.5 : i/(count-1); const baseY=height*(0.12+0.72*frac); const amp=(18+10*Math.sin(i*1.7))*dprRef.current; const phase=i*Math.PI/5; const step=Math.max(58, Math.floor(width/22)); const bulbs=[]; for(let x=step*0.5; x<width; x+=step){ const y=baseY + Math.sin((x/width)*Math.PI*2 + phase) * amp; bulbs.push(new Bulb(x,y)); } const yFunc = x => baseY + Math.sin((x/width)*Math.PI*2 + phase) * amp; garlands.push({bulbs,yFunc}); } }
        function drawGarlandWire(yFunc){ ctx.save(); ctx.lineWidth=Math.max(1.5,2*dprRef.current); ctx.strokeStyle='#2a3b48'; ctx.beginPath(); for(let x=0;x<=width;x+=8){ const y=yFunc(x); if(x===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);} ctx.stroke(); ctx.restore(); }
        function drawGarlands(t){ for(const g of garlands){ drawGarlandWire(g.yFunc); for(let i=0;i<g.bulbs.length;i++) g.bulbs[i].draw(ctx, t*(1+i*0.002)); } }

        // visuals helpers
        function rand(min,max){ return Math.random()*(max-min)+min; }
        function spawnSparkBurst(cx,cy,count=70){ for(let i=0;i<count;i++) sparks.push(new Spark(cx+rand(-1.5,1.5), cy+rand(-1.5,1.5))); }
        class DustParticle{ constructor(x,y){ this.x=x; this.y=y; this.vx=rand(-60,60); this.vy=rand(-80,-10); this.maxLife=rand(0.9,1.8); this.life=this.maxLife; } update(dt){ this.vy+=120*dt; this.x+=this.vx*dt; this.y+=this.vy*dt; this.life-=dt; } draw(ctx){ const a=Math.max(0,this.life/this.maxLife); ctx.fillStyle=`rgba(255,255,255,${0.9*a})`; ctx.fillRect(this.x,this.y,1.5,1.5);} dead(){return this.life<=0;} }
        class Spark{ constructor(x,y,speed=rand(60,160)){ this.x=x; this.y=y; this.px=x; this.py=y; const a=rand(0,Math.PI*2); this.vx=Math.cos(a)*speed; this.vy=Math.sin(a)*speed - rand(0,40); this.maxLife=rand(0.35,0.9); this.life=this.maxLife; } update(dt){ this.px=this.x; this.py=this.y; this.vx*=0.985; this.vy*=0.985; this.vy+=80*dt; this.x+=this.vx*dt; this.y+=this.vy*dt; this.life-=dt; } draw(ctx){ const a=Math.max(0,this.life/this.maxLife); ctx.strokeStyle=`rgba(255,220,150,${0.8*a})`; ctx.lineWidth=Math.max(1,1.2*dprRef.current); ctx.beginPath(); ctx.moveTo(this.px,this.py); ctx.lineTo(this.x,this.y); ctx.stroke(); ctx.fillStyle=`rgba(255,255,255,${0.7*a})`; ctx.fillRect(this.x-0.7,this.y-0.7,1.4,1.4);} dead(){return this.life<=0;} }

        class BurstSpark extends Spark{ constructor(x,y,speed,color){ super(x,y,speed); this.color=color; } draw(ctx){ const a=Math.max(0,this.life/this.maxLife); ctx.strokeStyle=this.color.replace('ALPHA',(0.85*a).toFixed(3)); ctx.lineWidth=Math.max(1,1.4*dprRef.current); ctx.beginPath(); ctx.moveTo(this.px,this.py); ctx.lineTo(this.x,this.y); ctx.stroke(); } }
        class FlashBurst{ constructor(x,y){ this.x=x; this.y=y; this.r=10; this.maxLife=0.25; this.life=this.maxLife;} update(dt){ this.r+=900*dt; this.life-=dt;} draw(ctx){ const a=Math.max(0,this.life/this.maxLife); const g=ctx.createRadialGradient(this.x,this.y,0,this.x,this.y,this.r); g.addColorStop(0,`rgba(255,255,255,${0.8*a})`); g.addColorStop(1,'transparent'); ctx.save(); ctx.globalCompositeOperation='lighter'; ctx.fillStyle=g; ctx.beginPath(); ctx.arc(this.x,this.y,this.r,0,Math.PI*2); ctx.fill(); ctx.restore(); } dead(){return this.life<=0;} }
        class Shockwave{ constructor(x,y){ this.x=x; this.y=y; this.r=0; this.maxLife=0.8; this.life=this.maxLife;} update(dt){ this.r+=420*dt; this.life-=dt;} draw(ctx){ const a=Math.max(0,this.life/this.maxLife); ctx.save(); ctx.globalAlpha=0.35*a; ctx.strokeStyle=`rgba(255,255,255,${0.8*a})`; ctx.lineWidth=Math.max(1.5,2*dprRef.current); ctx.beginPath(); ctx.arc(this.x,this.y,this.r,0,Math.PI*2); ctx.stroke(); ctx.restore(); } dead(){return this.life<=0;} }
        function fireworkBoom(cx,cy){ const N=Math.floor(200+Math.random()*120); const baseSpeed=rand(180,360); const palette=shuffle(FW_COLORS).slice(0,3); for(let i=0;i<N;i++){ const color=palette[i%palette.length]; const s=baseSpeed*(0.7+Math.random()*0.6); sparks.push(new BurstSpark(cx,cy,s,color)); } flashes.push(new FlashBurst(cx,cy)); shockwaves.push(new Shockwave(cx,cy)); for(let i=0;i<80;i++) dust.push(new DustParticle(cx+rand(-2,2), cy+rand(-2,2))); }

        // shapes
        function drawArm(ctx,r,rot){ ctx.save(); ctx.rotate(rot); ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(0,-r); const t1=-r*0.55, t2=-r*0.8; ctx.moveTo(0,t1); ctx.lineTo(r*0.22, t1+r*0.18); ctx.moveTo(0,t1); ctx.lineTo(-r*0.22, t1+r*0.18); ctx.moveTo(0,t2); ctx.lineTo(r*0.18, t2+r*0.16); ctx.moveTo(0,t2); ctx.lineTo(-r*0.18, t2+r*0.16); ctx.stroke(); ctx.restore(); }
        class Flake{ constructor(x,y,r){ this.x=x; this.y=y; this.r=r; this.vy=rand(8,20)*(0.4+r*0.1); this.drift=rand(8,18); this.phase=Math.random()*Math.PI*2; } update(dt){ this.y+=this.vy*dt; this.x+=Math.sin(this.phase+this.y*0.01)*this.drift*dt; const gh=groundHAt(this.x); if(this.y+this.r >= height-gh){ addSnowWide(this.x, this.r*3, 10); this.y=-10; this.x=rand(0,width);} else if(this.y-this.r > height+10){ this.y=-10; this.x=rand(0,width);} if(this.x<-20) this.x=width+20; if(this.x>width+20) this.x=-20; } draw(ctx){ ctx.beginPath(); ctx.arc(this.x,this.y,this.r,0,Math.PI*2); ctx.fillStyle='rgba(255,255,255,0.9)'; ctx.fill(); } }
        class BigFlake{ constructor(x,y,r){ this.x=x; this.y=y; this.r=r; this.vy=rand(20,35); this.spin=rand(-0.6,0.6); this.a=rand(0,Math.PI*2); this.swayPhase=rand(0,Math.PI*2); this.swayAmp=rand(10,28);} update(dt){ this.y+=this.vy*dt; this.a+=this.spin*dt; this.x+=Math.sin(this.swayPhase+this.y*0.015)*this.swayAmp*dt; const gh=groundHAt(this.x); if(this.y+this.r >= height-gh){ addSnowWide(this.x, this.r*6, 30); for(let i=0;i<Math.floor(20+this.r*2);i++) dust.push(new DustParticle(this.x+rand(-this.r*0.5,this.r*0.5), height-gh+rand(-6,0))); this.y=-40; this.x=rand(this.r+10, width-this.r-10); this.a=rand(0,Math.PI*2);} } isOff(){ return this.y-this.r>height+40; } hit(px,py){ const dx=px-this.x, dy=py-this.y; return dx*dx+dy*dy <= (this.r+6)*(this.r+6);} draw(ctx){ ctx.save(); ctx.translate(this.x,this.y); ctx.rotate(this.a); ctx.lineWidth=Math.max(1,this.r*0.08); ctx.lineJoin='round'; ctx.strokeStyle='rgba(255,255,255,0.95)'; for(let i=0;i<6;i++){ const arm=(Math.PI*2*i)/6; drawArm(ctx,this.r,arm);} ctx.restore(); } }
        class HexLogo{ constructor(x,y,r){ this.x=x; this.y=y; this.r=r; this.vy=rand(26,40); this.a=rand(0,Math.PI*2); this.va=rand(-0.8,0.8); this.sway=rand(12,22); this.phase=rand(0,Math.PI*2);} update(dt){ this.y+=this.vy*dt; this.a+=this.va*dt; this.x+=Math.sin(this.phase+this.y*0.012)*this.sway*dt;} isOff(){ return this.y-this.r>height+50;} hit(px,py){ const dx=px-this.x, dy=py-this.y; return dx*dx+dy*dy <= (this.r+6)*(this.r+6);} draw(ctx){ ctx.save(); ctx.translate(this.x,this.y); ctx.rotate(this.a); const R=this.r, r=R*0.88; const halo=ctx.createRadialGradient(0,0,0,0,0,R*2.6); halo.addColorStop(0,'rgba(160,200,255,0.25)'); halo.addColorStop(1,'transparent'); ctx.globalCompositeOperation='lighter'; ctx.fillStyle=halo; ctx.beginPath(); ctx.arc(0,0,R*2.6,0,Math.PI*2); ctx.fill(); ctx.globalCompositeOperation='source-over'; hexPath(ctx,R); ctx.lineWidth=Math.max(2,R*0.12); ctx.strokeStyle='white'; ctx.stroke(); hexPath(ctx,r); const ig=ctx.createLinearGradient(-r,-r, r,r); ig.addColorStop(0,'#87b5ff'); ig.addColorStop(1,'#d3e5ff'); ctx.fillStyle=ig; ctx.fill(); ctx.restore(); } }
        function hexPath(ctx,R){ ctx.beginPath(); for(let i=0;i<6;i++){ const ang=Math.PI/6 + i*Math.PI/3; const x=Math.cos(ang)*R, y=Math.sin(ang)*R; if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);} ctx.closePath(); }

        const garlandCountRef = { get current(){ return garlandCount; } };
        const specialRate=0.12, logoRate=0.025;

        function resize(){ const parent=canvas.parentElement; const rect=parent.getBoundingClientRect(); const dpr=Math.min(window.devicePixelRatio||1,2); dprRef.current=dpr; width=Math.max(1,Math.floor(rect.width*dpr)); height=Math.max(1,Math.floor(rect.height*dpr)); canvas.width=width; canvas.height=height; canvas.style.width=rect.width+'px'; canvas.style.height=rect.height+'px'; layoutGarlands(); initGround(); buildParallax(); }

        function addFlake(){ const r=Math.pow(Math.random(),2)*2.2 + 0.6; flakes.push(new Flake(rand(0,width), -10, r)); }
        function addSpecial(){ const r=rand(16,30); special.push(new BigFlake(rand(r+10, width-r-10), -40, r)); }
        function addLogo(){ const r=rand(20,34); logos.push(new HexLogo(rand(r+12, width-r-12), -50, r)); }

        function drawBackground(){ const g=ctx.createLinearGradient(0,0,0,height); g.addColorStop(0,'#0b1220'); g.addColorStop(1,'#162943'); ctx.fillStyle=g; ctx.fillRect(0,0,width,height); drawParallax(elapsed); ctx.globalAlpha=0.08; for(let i=0;i<3;i++){ const cx=Math.random()*width, cy=Math.random()*height, r=Math.random()*200+120; const rg=ctx.createRadialGradient(cx,cy,0,cx,cy,r); rg.addColorStop(0,'#ffffff'); rg.addColorStop(1,'transparent'); ctx.fillStyle=rg; ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.fill(); } ctx.globalAlpha=1; }

        function playBell(pan){ if(!soundRef.current) return; const actx=audioRef.current; if(!actx) return; const now=actx.currentTime; const master=actx.createGain(); master.gain.setValueAtTime(0.0001,now); master.gain.exponentialRampToValueAtTime(0.8,now+0.01); master.gain.exponentialRampToValueAtTime(0.0001,now+1.5); const sp=actx.createStereoPanner?actx.createStereoPanner():null; if(sp) sp.pan.setValueAtTime(Math.max(-1,Math.min(1,pan)),now); const dest=sp||master; if(sp) master.connect(sp); dest.connect(actx.destination); const base=[659.26,783.99,880.0,987.77,1046.5]; const f0=base[Math.floor(Math.random()*base.length)]*rand(0.98,1.02); function part(m,g0,dec,t='sine'){ const o=actx.createOscillator(); o.type=t; o.frequency.setValueAtTime(f0*m,now); const g=actx.createGain(); g.gain.setValueAtTime(g0,now); g.gain.exponentialRampToValueAtTime(0.0001,now+dec); o.connect(g).connect(master); o.start(now); o.stop(now+dec);} part(1.0,0.6,1.2,'sine'); part(2.41,0.25,1.0,'sine'); part(3.79,0.15,0.9,'triangle'); part(5.2,0.07,0.6,'triangle'); const click=actx.createOscillator(); const cg=actx.createGain(); click.type='square'; click.frequency.setValueAtTime(f0*1.5,now); cg.gain.setValueAtTime(0.12,now); cg.gain.exponentialRampToValueAtTime(0.0001,now+0.08); click.connect(cg).connect(master); click.start(now); click.stop(now+0.09); }
        function playTriadChime(pan){ if(!soundRef.current) return; const actx=audioRef.current; if(!actx) return; const now=actx.currentTime; const master=actx.createGain(); master.gain.setValueAtTime(0.0001,now); master.gain.exponentialRampToValueAtTime(0.9,now+0.01); master.gain.exponentialRampToValueAtTime(0.0001,now+1.8); const sp=actx.createStereoPanner?actx.createStereoPanner():null; if(sp) sp.pan.setValueAtTime(Math.max(-1,Math.min(1,pan)),now); const dest=sp||master; if(sp) master.connect(sp); dest.connect(actx.destination); const roots=[587.33,659.26,739.99]; const root=roots[Math.floor(Math.random()*roots.length)]*rand(0.98,1.02); const tri=[1.0,1.25,1.5]; const offs=[0,0.06,0.12]; function bellAt(start,f0){ function part(m,g0,dec,t='sine'){ const o=actx.createOscillator(), g=actx.createGain(); o.type=t; o.frequency.setValueAtTime(f0*m, now+start); g.gain.setValueAtTime(g0, now+start); g.gain.exponentialRampToValueAtTime(0.0001, now+start+dec); o.connect(g).connect(master); o.start(now+start); o.stop(now+start+dec);} part(1.0,0.5,1.2,'sine'); part(2.0,0.18,1.0,'sine'); part(3.0,0.12,0.9,'triangle'); const click=actx.createOscillator(), cg=actx.createGain(); click.type='square'; click.frequency.setValueAtTime(f0*1.5, now+start); cg.gain.setValueAtTime(0.1, now+start); cg.gain.exponentialRampToValueAtTime(0.0001, now+start+0.08); click.connect(cg).connect(master); click.start(now+start); click.stop(now+start+0.09);} for(let i=0;i<3;i++) bellAt(offs[i], root*tri[i]); }

        function onPointerDown(e){ ensureAudio(); setHintVisible(false); const rect=canvas.getBoundingClientRect(); const px=(e.clientX-rect.left)*dprRef.current; const py=(e.clientY-rect.top)*dprRef.current; tPX=px/width; tPY=py/height; for(let i=logos.length-1;i>=0;i--){ const L=logos[i]; if(L.hit(px,py)){ const pan=(px/width)*2-1; playTriadChime(pan); fireworkBoom(L.x,L.y); removeSnow(L.x,16); logos.splice(i,1); return; } } let hit=false; for(let i=special.length-1;i>=0;i--){ const f=special[i]; if(f.hit(px,py)){ shatter(f.x,f.y,f.r); const pan=(px/width)*2-1; playBell(pan); spawnSparkBurst(f.x,f.y,Math.floor(60+f.r*3)); removeSnow(f.x, Math.max(8,f.r)); special.splice(i,1); hit=true; break; } } if(!hit){ removeSnow(px,8); }
        }

        function shatter(x,y,r){ const n=Math.floor(60+r*2); for(let i=0;i<n;i++) dust.push(new DustParticle(x+rand(-2,2), y+rand(-2,2))); }

        const specialRate=0.12, logoRate=0.025; // spawn rates

        function loop(now){ if(!running) return; const dt=Math.min(0.05,(now-last)/1000); last=now; elapsed+=dt; tPX=0.5+0.10*Math.sin(elapsed*0.07+phaseX); tPY=0.5+0.04*Math.cos(elapsed*0.11+phaseY); pX+=(tPX-pX)*0.02; pY+=(tPY-pY)*0.02; while(flakes.length<flakeCountRef.current) addFlake(); if(Math.random() < specialRate*dt) addSpecial(); if(hexRef.current && Math.random() < logoRate*dt) addLogo(); for(let i=0;i<flakes.length;i++) flakes[i].update(dt); for(let i=special.length-1;i>=0;i--){ special[i].update(dt); if(special[i].isOff()) special.splice(i,1);} for(let i=logos.length-1;i>=0;i--){ logos[i].update(dt); if(logos[i].isOff()) logos.splice(i,1);} for(let i=dust.length-1;i>=0;i--){ dust[i].update(dt); if(dust[i].dead()) dust.splice(i,1);} for(let i=sparks.length-1;i>=0;i--){ sparks[i].update(dt); if(sparks[i].dead()) sparks.splice(i,1);} for(let i=flashes.length-1;i>=0;i--){ flashes[i].update(dt); if(flashes[i].dead()) flashes.splice(i,1);} for(let i=shockwaves.length-1;i>=0;i--){ shockwaves[i].update(dt); if(shockwaves[i].dead()) shockwaves.splice(i,1);} drawBackground(); if(xmasRef.current) drawGarlands(elapsed); for(let i=0;i<flakes.length;i++) flakes[i].draw(ctx); for(let i=0;i<special.length;i++) special[i].draw(ctx); for(let i=0;i<logos.length;i++) logos[i].draw(ctx); for(let i=0;i<dust.length;i++) dust[i].draw(ctx); if(flashes.length||shockwaves.length||sparks.length){ ctx.save(); for(let i=0;i<flashes.length;i++) flashes[i].draw(ctx); ctx.globalCompositeOperation='lighter'; for(let i=0;i<sparks.length;i++) sparks[i].draw(ctx); ctx.restore(); for(let i=0;i<shockwaves.length;i++) shockwaves[i].draw(ctx); } drawSnowGround(); if(xmasRef.current && Math.random()<0.02){ spawnSparkBurst(rand(0,width), rand(height*0.05,height*0.2), Math.floor(rand(3,6))); } if(sparks.length>3000) sparks.splice(0, sparks.length-3000); rafRef.current=requestAnimationFrame(loop); }

        function onVisibility(){ if(document.hidden){ running=false; if(rafRef.current) cancelAnimationFrame(rafRef.current); } else { running=true; last=performance.now(); rafRef.current=requestAnimationFrame(loop);} }

        function rand(min,max){ return Math.random()*(max-min)+min; }

        function runSelfTests(){ const mid=Math.floor(width/2); const bi=Math.floor(mid/groundBinW); const before=groundBins[bi]; addSnow(mid,10); const afterAdd=groundBins[bi]; removeSnow(mid,5); const afterRem=groundBins[bi]; const saved=groundBins.slice(); const sumBefore=saved.reduce((a,b)=>a+b,0); addSnowWide(mid,6,30); const changed=groundBins.reduce((n,v,i)=>n+(v!==saved[i]?1:0),0); const sumAfter=groundBins.reduce((a,b)=>a+b,0); const wideMany = changed >= Math.max(10, Math.floor(30*1.5)); const wideUp = sumAfter > sumBefore; groundBins = saved; try{ console.table([{test:'canvas context',pass:!!ctx},{test:'ground bins exist',pass:groundBins.length>0},{test:'addSnow increases',pass:afterAdd>before},{test:'removeSnow decreases',pass:afterRem<afterAdd},{test:'addSnowWide affects many bins',pass:wideMany},{test:'addSnowWide increases total',pass:wideUp},{test:'audio ctx (after click)',pass:!!audioRef.current}]); }catch(e){} }

        function resizeAll(){ resize(); }
        function addSpecialMaybe(){ }

        resize(); window.addEventListener('resize', resize); canvas.addEventListener('pointerdown', onPointerDown); document.addEventListener('visibilitychange', onVisibility); rafRef.current=requestAnimationFrame(loop); runSelfTests();
        return ()=>{ running=false; if(rafRef.current) cancelAnimationFrame(rafRef.current); window.removeEventListener('resize', resize); canvas.removeEventListener('pointerdown', onPointerDown); document.removeEventListener('visibilitychange', onVisibility); };
      }, [xmasMode, soundOn, garlandCount, hexOn]);

      return (
        <div className="relative w-full h-screen overflow-hidden bg-slate-900">
          <canvas ref={canvasRef} className="absolute inset-0 block" />
          {uiVisible ? (
            <div className="absolute right-4 top-4 z-10 flex flex-wrap gap-2">
              <button onClick={()=>setXmasMode(v=>!v)} className="rounded-xl bg-white/10 px-3 py-2 text-xs text-white backdrop-blur hover:bg-white/20 border border-white/20">{xmasMode?"V√°noƒçn√≠ m√≥d: Zap":"V√°noƒçn√≠ m√≥d: Vyp"}</button>
              <button onClick={()=>setSoundOn(v=>!v)} className="rounded-xl bg-white/10 px-3 py-2 text-xs text-white backdrop-blur hover:bg-white/20 border border-white/20">{soundOn?"Zvuk: Zap":"Zvuk: Vyp"}</button>
              <div className="flex items-center gap-1 rounded-xl bg-white/10 px-2 py-2 text-xs text-white border border-white/20 backdrop-blur">
                <span>Ukl√°d√°n√≠</span>
                <button onClick={()=>setDepositScale(1)} className={`px-2 py-1 rounded ${depositScale===1?'bg-white/30':'bg-white/10'}`}>1√ó</button>
                <button onClick={()=>setDepositScale(0.1)} className={`px-2 py-1 rounded ${depositScale===0.1?'bg-white/30':'bg-white/10'}`}>10√ó</button>
                <button onClick={()=>setDepositScale(0.01)} className={`px-2 py-1 rounded ${depositScale===0.01?'bg-white/30':'bg-white/10'}`}>100√ó</button>
                <button onClick={()=>setDepositScale(0.001)} className={`px-2 py-1 rounded ${depositScale===0.001?'bg-white/30':'bg-white/10'}`}>1000√ó</button>
                <button onClick={()=>setDepositScale(0)} className={`px-2 py-1 rounded ${depositScale===0?'bg-white/30':'bg-white/10'}`}>0√ó</button>
                <span className="ml-1 opacity-80">√ó{depositScale}</span>
              </div>
              <button onClick={()=>setUiVisible(false)} title="Skr√Ωt rozhran√≠" className="rounded-xl bg-white/10 px-3 py-2 text-xs text-white backdrop-blur hover:bg-white/20 border border-white/20">üëÅÔ∏è Skr√Ωt</button>
            </div>
          ) : (
            <div className="absolute right-4 top-4 z-10">
              <button onClick={()=>setUiVisible(true)} title="Zobrazit rozhran√≠" className="rounded-full bg-white/10 p-2 text-white border border-white/20 backdrop-blur hover:bg-white/20">üëÅÔ∏è</button>
            </div>
          )}
          {hintVisible && (
            <div className="absolute inset-x-0 bottom-8 z-10 mx-auto w-fit rounded-full bg-white/10 px-4 py-2 text-white text-xs border border-white/20 backdrop-blur">
              Klikni kamkoliv: rozbije≈° vloƒçku/hexagon, jiskry a odmete≈° sn√≠h.
            </div>
          )}
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(React.createElement(SnowScreensaver));
  </script>
</body>
</html>
